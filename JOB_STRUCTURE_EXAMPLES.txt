================================================================================
DYNAMIC JOB BUILDER - JOB STRUCTURE VISUALIZATION
================================================================================

This document shows the Spring Batch Job structures generated by DynamicJobBuilder
for different workflow patterns.

================================================================================
EXAMPLE 1: Single Linear Flow
================================================================================

Input Canvas:
  Start → FileSource → Reformat → FileSink

ExecutionPlan:
  entryStepIds: [FileSource]
  steps: {
    FileSource: { nextSteps: [Reformat] }
    Reformat:   { nextSteps: [FileSink] }
    FileSink:   { nextSteps: [] }
  }

Generated Job Structure:
┌─────────────────────────────────────────────────────────────┐
│ Job: workflow-abc123                                         │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ Flow: main-flow                                          │ │
│ │ ┌───────────────┐   ┌───────────────┐   ┌────────────┐ │ │
│ │ │  FileSource   │──▶│   Reformat    │──▶│  FileSink  │ │ │
│ │ │  Step         │   │   Step        │   │  Step      │ │ │
│ │ └───────────────┘   └───────────────┘   └────────────┘ │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

DynamicJobBuilder Code Path:
  1. buildMainFlow() → single entry: FileSource
  2. buildFlowFromStep("FileSource")
     - create Step for FileSource
     - nextSteps = [Reformat]
     - buildFlowFromStep("Reformat") recursively
     - chain with .on("*").to(reformatFlow)
  3. buildFlowFromStep("Reformat")
     - create Step for Reformat
     - nextSteps = [FileSink]
     - buildFlowFromStep("FileSink") recursively
     - chain with .on("*").to(fileSinkFlow)
  4. buildFlowFromStep("FileSink")
     - create Step for FileSink
     - nextSteps = []
     - end with .on("*").end()

================================================================================
EXAMPLE 2: Multi-Source Parallel Entry
================================================================================

Input Canvas:
  Start ──┬─→ FileSource_A
          └─→ FileSource_B

ExecutionPlan:
  entryStepIds: [FileSource_A, FileSource_B]
  steps: {
    FileSource_A: { nextSteps: [] }
    FileSource_B: { nextSteps: [] }
  }

Generated Job Structure:
┌──────────────────────────────────────────────────────────────────┐
│ Job: workflow-xyz789                                              │
│ ┌──────────────────────────────────────────────────────────────┐ │
│ │ Flow: main-split (with SimpleAsyncTaskExecutor)              │ │
│ │                                                               │ │
│ │ ┌─────────────────────────┐  ┌─────────────────────────┐    │ │
│ │ │ Branch 1 (Thread-1)     │  │ Branch 2 (Thread-2)     │    │ │
│ │ │ ┌─────────────────────┐ │  │ ┌─────────────────────┐ │    │ │
│ │ │ │   FileSource_A      │ │  │ │   FileSource_B      │ │    │ │
│ │ │ │   Step              │ │  │ │   Step              │ │    │ │
│ │ │ └─────────────────────┘ │  │ └─────────────────────┘ │    │ │
│ │ └─────────────────────────┘  └─────────────────────────┘    │ │
│ │                                                               │ │
│ │ ◀─────────────────── JOIN ───────────────────────▶           │ │
│ └──────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────┘

DynamicJobBuilder Code Path:
  1. buildMainFlow() → multiple entries: [FileSource_A, FileSource_B]
  2. Create flow for each:
     - flowA = buildFlowFromStep("FileSource_A")
     - flowB = buildFlowFromStep("FileSource_B")
  3. createSplitFlow([flowA, flowB], "main-split")
     - new FlowBuilder("main-split")
     - .split(new SimpleAsyncTaskExecutor())
     - .add([flowA, flowB])
  4. Both branches execute concurrently

================================================================================
EXAMPLE 3: Branching with Parallel Execution Hint
================================================================================

Input Canvas:
  FileSource → ┬─→ Transform_A → Sink_A
               └─→ Transform_B → Sink_B

ExecutionPlan:
  entryStepIds: [FileSource]
  steps: {
    FileSource:   { nextSteps: [Transform_A, Transform_B], hints: {mode: PARALLEL} }
    Transform_A:  { nextSteps: [Sink_A] }
    Transform_B:  { nextSteps: [Sink_B] }
    Sink_A:       { nextSteps: [] }
    Sink_B:       { nextSteps: [] }
  }

Generated Job Structure:
┌────────────────────────────────────────────────────────────────────┐
│ Job: workflow-def456                                                │
│ ┌────────────────────────────────────────────────────────────────┐ │
│ │ Flow: main-flow                                                 │ │
│ │                                                                  │ │
│ │ ┌────────────────┐                                              │ │
│ │ │  FileSource    │                                              │ │
│ │ │  Step          │                                              │ │
│ │ └────────────────┘                                              │ │
│ │         │                                                        │ │
│ │         ▼                                                        │ │
│ │ ┌─────────────────────────────────────────────────────────┐    │ │
│ │ │ Split Flow: FileSource-split                             │    │ │
│ │ │                                                           │    │ │
│ │ │ ┌────────────────┐              ┌────────────────┐      │    │ │
│ │ │ │ Branch 1       │              │ Branch 2       │      │    │ │
│ │ │ │ ┌────────────┐ │              │ ┌────────────┐ │      │    │ │
│ │ │ │ │Transform_A │ │              │ │Transform_B │ │      │    │ │
│ │ │ │ └────────────┘ │              │ └────────────┘ │      │    │ │
│ │ │ │      │         │              │      │         │      │    │ │
│ │ │ │      ▼         │              │      ▼         │      │    │ │
│ │ │ │ ┌────────────┐ │              │ ┌────────────┐ │      │    │ │
│ │ │ │ │  Sink_A    │ │              │ │  Sink_B    │ │      │    │ │
│ │ │ │ └────────────┘ │              │ └────────────┘ │      │    │ │
│ │ │ └────────────────┘              └────────────────┘      │    │ │
│ │ └─────────────────────────────────────────────────────────┘    │ │
│ └────────────────────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────────────────────┘

DynamicJobBuilder Code Path:
  1. buildFlowFromStep("FileSource")
  2. nextSteps = [Transform_A, Transform_B]
  3. Check executionHints.mode == PARALLEL → true
  4. Create branch flows:
     - branchA = buildFlowFromStep("Transform_A") → includes Sink_A
     - branchB = buildFlowFromStep("Transform_B") → includes Sink_B
  5. createSplitFlow([branchA, branchB], "FileSource-split")
  6. Chain: FileSource.on("*").to(splitFlow)

================================================================================
EXAMPLE 4: Error Routing
================================================================================

Input Canvas:
  FileSource → Filter ─main─→ Sink
                     └─reject─→ ErrorSink

ExecutionPlan:
  entryStepIds: [FileSource]
  steps: {
    FileSource: { nextSteps: [Filter] }
    Filter:     { nextSteps: [Sink], errorSteps: [ErrorSink] }
    Sink:       { nextSteps: [] }
    ErrorSink:  { nextSteps: [] }
  }

Generated Job Structure:
┌────────────────────────────────────────────────────────────────┐
│ Job: workflow-err999                                            │
│ ┌────────────────────────────────────────────────────────────┐ │
│ │ Flow: main-flow                                             │ │
│ │                                                             │ │
│ │ ┌──────────────┐       ┌──────────────┐                    │ │
│ │ │  FileSource  │──────▶│   Filter     │                    │ │
│ │ │  Step        │       │   Step       │                    │ │
│ │ └──────────────┘       └──────────────┘                    │ │
│ │                              │  │                           │ │
│ │                 on("*")      │  │ on("FAILED")             │ │
│ │                              │  │                           │ │
│ │                              ▼  ▼                           │ │
│ │                  ┌──────────────┐  ┌──────────────┐        │ │
│ │                  │    Sink      │  │  ErrorSink   │        │ │
│ │                  │    Step      │  │  Step        │        │ │
│ │                  └──────────────┘  └──────────────┘        │ │
│ └────────────────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────────────────┘

DynamicJobBuilder Code Path:
  1. buildFlowFromStep("FileSource")
  2. nextSteps = [Filter]
  3. buildFlowFromStep("Filter")
     - errorSteps = [ErrorSink]
     - Build error flow: errorFlow = buildFlowFromStep("ErrorSink")
     - Add transition: .on("FAILED").to(errorFlow)
     - nextSteps = [Sink]
     - Build main flow: mainFlow = buildFlowFromStep("Sink")
     - Add transition: .on("*").to(mainFlow)

Execution Behavior:
  - If Filter step completes normally: proceeds to Sink
  - If Filter step fails: proceeds to ErrorSink
  - Job continues regardless (error routing, not failure)

================================================================================
EXAMPLE 5: Complex DAG with Multiple Patterns
================================================================================

Input Canvas:
  Start ──┬─→ Source_A ──┬─→ Transform_A → Sink_A
          │              └─→ Transform_B → Sink_B
          └─→ Source_B ────→ Validate ─pass─→ Sink_C
                                      └─fail─→ ErrorSink

ExecutionPlan:
  entryStepIds: [Source_A, Source_B]
  steps: {
    Source_A:     { nextSteps: [Transform_A, Transform_B], hints: {mode: PARALLEL} }
    Source_B:     { nextSteps: [Validate] }
    Transform_A:  { nextSteps: [Sink_A] }
    Transform_B:  { nextSteps: [Sink_B] }
    Validate:     { nextSteps: [Sink_C], errorSteps: [ErrorSink] }
    Sink_A:       { nextSteps: [] }
    Sink_B:       { nextSteps: [] }
    Sink_C:       { nextSteps: [] }
    ErrorSink:    { nextSteps: [] }
  }

Generated Job Structure:
┌──────────────────────────────────────────────────────────────────────┐
│ Job: workflow-complex                                                 │
│ ┌──────────────────────────────────────────────────────────────────┐ │
│ │ Flow: main-split                                                  │ │
│ │                                                                    │ │
│ │ ┌──────────────────────────┐   ┌──────────────────────────────┐  │ │
│ │ │ Branch 1 (Thread-1)      │   │ Branch 2 (Thread-2)          │  │ │
│ │ │                          │   │                              │  │ │
│ │ │ ┌──────────┐             │   │ ┌──────────┐                │  │ │
│ │ │ │ Source_A │             │   │ │ Source_B │                │  │ │
│ │ │ └──────────┘             │   │ └──────────┘                │  │ │
│ │ │      │                   │   │      │                      │  │ │
│ │ │      ▼                   │   │      ▼                      │  │ │
│ │ │ ┌────────────────────┐   │   │ ┌──────────┐                │  │ │
│ │ │ │ Split: Source_A    │   │   │ │ Validate │                │  │ │
│ │ │ │ ┌────────────────┐ │   │   │ └──────────┘                │  │ │
│ │ │ │ │ Transform_A    │ │   │   │   │      │                  │  │ │
│ │ │ │ │    ↓           │ │   │   │   │ on("*")  on("FAILED")   │  │ │
│ │ │ │ │ Sink_A         │ │   │   │   ▼      ▼                  │  │ │
│ │ │ │ ├────────────────┤ │   │   │ ┌────┐ ┌─────────┐          │  │ │
│ │ │ │ │ Transform_B    │ │   │   │ │Sink│ │ErrorSink│          │  │ │
│ │ │ │ │    ↓           │ │   │   │ │ _C │ │         │          │  │ │
│ │ │ │ │ Sink_B         │ │   │   │ └────┘ └─────────┘          │  │ │
│ │ │ │ └────────────────┘ │   │   │                              │  │ │
│ │ │ └────────────────────┘   │   │                              │  │ │
│ │ └──────────────────────────┘   └──────────────────────────────┘  │ │
│ └──────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────┘

Execution Order:
  1. Source_A (Thread-1) and Source_B (Thread-2) start in parallel
  2. Source_A completes → triggers Transform_A and Transform_B in parallel
  3. Source_B completes → triggers Validate
  4. Transform_A → Sink_A (Thread-1a)
  5. Transform_B → Sink_B (Thread-1b)
  6. Validate → either Sink_C or ErrorSink (Thread-2)
  7. All branches complete → Job completes

================================================================================
KEY IMPLEMENTATION DETAILS
================================================================================

Step Creation (StepFactory.buildStep):
  ┌──────────────────────────────────────────┐
  │ Step: <nodeId>                            │
  │                                           │
  │ Reader:    executor.createReader()        │
  │ Processor: executor.createProcessor()     │
  │ Writer:    executor.createWriter()        │
  │                                           │
  │ Chunk Size: 1000 (or from hints)          │
  │                                           │
  │ Listeners:                                │
  │   • MetricsCollectionListener (if enabled)│
  │                                           │
  │ Fault Tolerance:                          │
  │   • Retry: retryLimit(n).retry(Ex.class) │
  │   • Skip:  skipLimit(n).skip(Ex.class)   │
  └──────────────────────────────────────────┘

Flow Building (DynamicJobBuilder.buildFlowFromStep):
  1. Create step from StepNode
  2. Start flow: new FlowBuilder(stepId + "-flow").start(step)
  3. Handle error steps:
       if (errorSteps != null)
         for each errorStep:
           errorFlow = buildFlowFromStep(errorStep)
           flowBuilder.on("FAILED").to(errorFlow)
  4. Handle next steps:
       if (nextSteps.size() == 1)
         nextFlow = buildFlowFromStep(nextStep)
         flowBuilder.on("*").to(nextFlow)
       else if (nextSteps.size() > 1 && PARALLEL hint)
         create branch flows
         splitFlow = createSplitFlow(branchFlows)
         flowBuilder.on("*").to(splitFlow)
  5. End flow: flowBuilder.on("*").end()

Split Creation (DynamicJobBuilder.createSplitFlow):
  ┌────────────────────────────────────────┐
  │ FlowBuilder(splitName)                  │
  │   .split(SimpleAsyncTaskExecutor)      │
  │   .add([flow1, flow2, ..., flowN])     │
  │   .build()                             │
  └────────────────────────────────────────┘

Job Assembly (DynamicJobBuilder.buildJob):
  ┌────────────────────────────────────────┐
  │ new JobBuilder(jobName, jobRepository) │
  │   .incrementer(RunIdIncrementer())     │
  │   .preventRestart()                    │
  │   .start(mainFlow)                     │
  │   .end()                               │
  │   .build()                             │
  └────────────────────────────────────────┘

================================================================================
